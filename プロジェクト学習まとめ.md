# 🎓 Python・プログラミング学習まとめ（最新版）

## 🔥 クラス・オブジェクト指向の完全理解
### インスタンス化の本質
```python
uploader = GCSUploader("bucket-name")  # オブジェクト作成
downloader = PowerDataDownloader()     # 同じ仕組み
df = pd.DataFrame(data)                # ライブラリも同様
```

**重要な気づき**: ライブラリも自作クラスも同じインスタンス化  
**設計思想**: 1つのオブジェクトが複数のメソッドを持つ  
**実用性**: upload_file() と upload_directory()、download_for_days() と download_for_month() を1つのオブジェクトで提供

### メソッドの階層設計
```python
def upload_directory(self, ...):
    for file in files:
        uri = self.upload_file(file)  # 単一処理の再利用

def download_for_days(self, days=5):
    months = self.get_required_months(days)  # 月計算の再利用
    for month in months:
        self.download_month_data(month)      # ダウンロードの再利用
```

**単一責任の原則**: 各メソッドが明確な役割を持つ  
**コードの再利用**: 複雑な処理を単純な処理の組み合わせで実現  
**保守性**: 1箇所修正すれば全体に反映

## 🔥 引数とパラメータの完全理解
### defの基本ルール
```python
class MyClass:
    def __init__(self, base_dir="data/raw"):
        #          ^^^^  ^^^^^^^^^^^^^^^^^
        #          self  デフォルト値付き引数
```

**クラス内メソッド**: 必ず最初は `self`  
**関数（クラス外）**: `self` 不要  
**デフォルト値**: `=` で指定  
**必須引数**: デフォルト値なし

### 関数 vs メソッドの違い
- **関数**: クラス外、selfなし、独立して動作
- **メソッド**: クラス内、selfあり、インスタンスに依存

## 🔥 argparseの完全理解
### argparseの4段階フロー
1. **argparseでパーサーオブジェクト作成**
2. **パーサーのadd_argument()で引数パターン設定**
3. **パーサーのparse_args()でnamespaceオブジェクト作成**
4. **必要に応じてnamespaceで条件分岐**

### オブジェクトの生成関係
```python
parser = ArgumentParser()    # パーサーオブジェクト作成
args = parser.parse_args()   # パーサーがNamespaceオブジェクトを生成して返す
```

**ArgumentParser**: 工場（ファクトリー）  
**Namespace**: 工場で作られる製品

### argparse必要性の条件
- **メソッド1つ**: コマンドライン・import両対応でもargparse不要
- **メソッド複数**: コマンド対応させるならargparse必要、コマンド対応なしなら不要

## 🔥 オブジェクト vs 属性の理解
### 概念の違い
- **オブジェクト**: 全体の入れ物・箱（`args = Namespace(...)`）
- **属性**: その箱の中に入っている個別の項目（`args.month`, `args.date`）

### Namespaceの構造
```
┌─ Namespaceオブジェクト ─┐
│  month: '202505'       │
│  date: None            │
│  days: 5               │
│  base_dir: 'data/raw'  │
└────────────────────────┘
```

## 🔥 Pathオブジェクトの実用理解
### パス操作の進化
```python
# 従来の方法
import os
path = base_dir + "/" + yyyymm
os.makedirs(path, exist_ok=True)

# Pathオブジェクト
from pathlib import Path
month_dir = self.base_dir / yyyymm  # 直感的な結合
month_dir.mkdir(parents=True, exist_ok=True)  # メソッドで操作
```

### クロスプラットフォーム対応
```python
# コードでは常に / を使用
path = Path("data") / "raw" / "202505"

# Windows: data\raw\202505
# Linux:   data/raw/202505
```

## 🔥 ログシステムの理解
### logging_config.pyの役割
- **新しいクラス作成**: していない
- **フォーマット・階層指定**: 設定用スクリプト
- **初期化**: `setup_logging()` で設定適用

### 階層継承の仕組み
```
'energy_env' (親) 
├── 'energy_env.data_processing' (子)
│   └── 'energy_env.data_processing.data_downloader' (孫)
```

**logging_config.py**: ロガーの設定を行う  
**各モジュール**: 設定済みロガーを取得・使用する

## 🔥 2つの実行パターンの理解
### `if __name__ == "__main__":` の役割
```python
# 直接実行時
if __name__ == "__main__":  # True
    main()  # argparseが動く

# import時
if __name__ == "__main__":  # False  
    main()  # 実行されない（スキップ）
```

### 設計パターン
- **直接実行**: コマンドラインツールとして動作
- **import**: ライブラリとして他から利用可能
- **1つのファイル**: 2つの用途を兼任

## 🔥 HTTPリクエストの理解
### requestsライブラリ
```python
response = requests.get(url)  # HTTPリクエスト送信
response.raise_for_status()   # エラーなら例外発生
```

**requests**: 外部ライブラリ（標準ライブラリではない）  
**raise_for_status()**: エラーを見逃さないようにする機能

## 🔥 **NEW** バリデーション設計の理解
### 責任分離によるバリデーション
```python
def get_months_from_date(self, date_str):
    # YYYYMMDD形式のバリデーション
    date = datetime.strptime(date_str, '%Y%m%d')
    # 未来日付チェック
    if date.date() > datetime.today().date():
        raise ValueError(f"未来の日付は指定できません")

def download_for_month(self, yyyymm):
    # YYYYMM形式のバリデーション
    month_date = datetime.strptime(yyyymm, '%Y%m')
    # 未来月チェック
    if month_date > datetime.today().replace(day=1):
        raise ValueError(f"未来の月は指定できません")
```

**各入り口で責任を持つ**: メソッドごとに適切なフォーマットチェック  
**早期エラー検出**: HTTPリクエスト前に不正入力を検出  
**UX改善**: 404エラーより分かりやすいメッセージ

## 🔥 **NEW** 標準ライブラリとテスト設計の理解
### 標準ライブラリの信頼
```python
# ❌ 不要なテスト
def test_datetime_works():
    result = datetime.strptime("20250101", '%Y%m%d')
    assert result.year == 2025  # 標準ライブラリのテスト

# ✅ 必要なテスト
def test_our_date_validation():
    downloader = PowerDataDownloader()
    with pytest.raises(ValueError):
        downloader.get_months_from_date("invalid")  # 我々のコードのテスト
```

**テスト原則**: 自分のコードをテスト、標準ライブラリはテスト不要  
**責任範囲**: フォーマットチェック vs 日付妥当性チェック  
**効率性**: 本質的なテストのみ実装

## 🔥 **NEW** Python文法の深い理解
### 三項演算子（条件式）
```python
# Python独自の自然言語風
status = "✓ 成功" if success else "✗ 失敗"

# 他言語の一般的形式
status = success ? "✓ 成功" : "✗ 失敗"  # JavaScript, Java, C等
```

**Pythonの特徴**: 読みやすさ重視の語順  
**英語に近い**: 「成功、もしsuccessなら、そうでなければ失敗」

### len()関数の型別動作
```python
len("hello")         # → 5（文字数）
len([1, 2, 3])       # → 3（要素数）
len({"a": 1})        # → 1（キー数）
```

**エクセルとの違い**: Pythonは「含まれているものの個数」概念

### sorted()の実用性
```python
months = {"202506", "202505"}  # set（順序不定）
sorted(months)  # → ['202505', '202506']（時系列順）
```

**setの順序問題**: 実行毎に表示順序が変わる可能性  
**sorted()の価値**: 安定した順序、デバッグ時の視認性向上

## 🔥 **NEW** 辞書とリストの深い理解
### 辞書アクセスの正確な記法
```python
# ✅ 正しい: 角括弧
results['success']   # 辞書アクセス

# ❌ 間違い: 波括弧  
results{'success'}   # エラー
```

### 辞書の値のみ取得
```python
download_results = {'success': ['202505'], 'failed': []}
download_results['success']  # → ['202505'] （リストのみ、キーは含まれない）
```

### append()による辞書内リスト操作
```python
results = {'success': [], 'failed': []}
results['success'].append('202505')
# 結果: {'success': ['202505'], 'failed': []}
```

## 🔥 **NEW** ループ制御の完全理解
### continue vs return の違い
```python
# continue: ループの今回をスキップ、ループは継続
for item in items:
    if condition:
        continue  # 次のitemへ
    process(item)

# return: 関数を終了、呼び出し元に戻る  
def function():
    for item in items:
        if condition:
            return  # 関数終了
        process(item)
```

**continue**: 「今回はパス、次で続行」  
**return**: 「関数終了、呼び出し元に戻る」

## 🔥 **NEW** ETLパイプライン設計の理解
### Extract-Transform-Load の流れ
```python
# Extract: データ取得
download_results = self.downloader.download_for_month(month)

# Transform: データ変換（今回は最小限）
successful_months = download_results['success']

# Load: データ保存
upload_results = self._upload_downloaded_data(successful_months)
```

### エラー耐性のある設計
```python
if not download_results['success']:
    # ダウンロード失敗時はアップロードをスキップ
    return {'overall_status': 'failed', 'message': '...'}

# 成功時のみアップロード実行
upload_results = self._upload_downloaded_data(download_results['success'])
```

### データライフサイクル管理
```python
# 日付付きバックアップ
f"archives/{month}/{today_str}"  # archives/202505/2025-06-12/

# 自動クリーンアップ
if (file_date < cutoff_date and file_date.day != last_day_of_month):
    blob.delete()  # 2週間より古く、月末でないファイルを削除
```

## 🔥 **NEW** Google Cloud Storage API の理解
### list_blobs() による一覧取得
```python
blobs = list(self.uploader.client.list_blobs(
    self.uploader.bucket, 
    prefix=archive_prefix
))
```

### パス構造の解析
```python
# "archives/202505/2025-06-01/202505.zip"
path_parts = blob.name.split('/')
date_str = path_parts[2]  # "2025-06-01"
```

## 🔥 **NEW** 日付・時刻処理の実用技術
### datetime.replace() による日付操作
```python
execution_date = datetime.today()     # 2025-06-12
first_day = execution_date.replace(day=1)  # 2025-06-01（月初作成）
```

### calendar.monthrange() による月末取得
```python
calendar.monthrange(2025, 6)  # (5, 30)
#                            ↑  ↑
#                        初日曜日 月の日数（=末日）
```

### strftime() による文字列変換
```python
date.strftime('%Y%m')     # "202506" 
date.strftime('%Y-%m-%d') # "2025-06-12"
```

## 🔥 **NEW** コンパイルとバイトコードの理解
### プログラミングでの exception = 「想定外の状況への対応システム」
```python
try:
    # 通常の流れを試す
    response = requests.get(url)
    response.raise_for_status()  # エラーがあればexceptionを発生させる
except Exception as e:  # e = exception（errorではない）
    # 「通常じゃない状況」が起きたら特別対応
    print("何か想定外のことが起きました")
```

**exception**: 想定外の問題・失敗・異常事象（日本語の「例外的に許可」とは真逆）

### Pythonの実行フロー
```
1. Python(.py) → 2. バイトコード(.pyc) → 3. 機械語（CPU実行）
```

**バイトコード**: 中間言語（共通フォーマット）  
**各OS用Pythonインタープリター**: バイトコード→機械語変換を担当

### クロスプラットフォームの仕組み
```
日本語（Pythonスクリプト）→ 英語（バイトコード）→ 各国語（各OS機械語）
```

## 🔥 **NEW** 環境管理とGitの関係
### Gitで管理されるもの vs されないもの
```python
# Git管理される
- ソースコード (.py ファイル)
- 設定ファイル (.gitignore等)

# Git管理されない
- 環境変数 (GOOGLE_APPLICATION_CREDENTIALS等)
- OS設定
- __pycache__/ (自動生成キャッシュ)
```

### 環境変数の設定
```cmd
# 一時的（ターミナルセッションのみ）
set GOOGLE_APPLICATION_CREDENTIALS=パス

# 永続的（Windows システム環境変数）
Windows + R → sysdm.cpl → 詳細設定 → 環境変数
```

## 🔥 **NEW** VS Code統合ターミナルの仕組み
### VS Code統合ターミナル vs 外部cmd
```bash
# VS Code統合ターミナル（推奨）
python -m tests.test_main_etl  # モジュール実行、src認識される

# 外部cmd・「専用ターミナルで実行」
python tests/test_main_etl.py  # スクリプト実行、srcが見えない
```

### `-m` フラグの重要性
```python
# python -m で実行
# → 現在のディレクトリがsys.pathに追加される
# → from src.module import ... が認識される

# python file.py で実行  
# → ファイルのディレクトリが基準
# → src が見えずimport エラー
```

### VS Code統合ターミナルの自動機能
- **仮想環境の自動アクティブ化**
- **プロジェクト設定の自動認識**
- **Python インタープリターの自動設定**

## 🔥 **NEW** 実際のETLパイプライン実行経験
### 実データでの動作確認
```python
# 実際に東電サイトからデータダウンロード
# → 31個のCSVファイル + ZIPファイル
# → Google Cloud Storageへ自動アップロード
# → 日付付きアーカイブ作成・古いファイルのクリーンアップ
```

### テスト設計の実践
```python
# 初期化テスト: 設定確認のみ
# 機能テスト: 実際のETL処理確認
# エラーハンドリング: 未来日付・無効フォーマットの検証
# 結果検証: 辞書構造とキーの存在確認
```

## 🔥 **NEW** ファイル処理とCSV加工の理解
### ファイル操作の基本パターン
```python
# os.path の基本メソッド
os.path.basename("/path/to/file.csv")  # → "file.csv" （ファイル名のみ）
os.path.dirname("/path/to/file.csv")   # → "/path/to" （ディレクトリのみ）
os.path.join(dir_name, filename)       # → フルパス生成
```

### CSVファイル処理の実践
```python
# ファイル全体を読み込み
with open(csv_path, 'r', encoding='shift-jis') as f:
    content = f.read()

# 行ごとに分割
lines = content.split('\n')

# 各行を個別処理
for i, line in enumerate(lines):
    # i = インデックス番号（何行目か）
    # line = その行の内容（文字列）
```

### enumerate() の完全理解
```python
data = ["apple", "banana", "cherry"]

for i, item in enumerate(data):
    print(f"{i}: {item}")
# 出力:
# 0: apple
# 1: banana  
# 2: cherry
```

**enumerate() = インデックス番号を自動で振ってくれる機能**

## 🔥 **NEW** 文字列処理の実用技術
### strip() による前後空白削除
```python
text = "  hello world  \n"
clean_text = text.strip()  # → "hello world"
```

**除去対象**: 空白、タブ、改行文字（\r\n）等

### 文字列の分割と結合
```python
# 分割
parts = "2025/4/1".split('/')  # → ["2025", "4", "1"]

# ゼロ埋め
month = "4".zfill(2)  # → "04" （2桁になるよう0埋め）

# 結合
date = f"{year}-{month}-{day}"  # → "2025-04-01"
```

## 🔥 **NEW** BigQueryテーブル設計の理解
### スキーマ設計の原則
```json
{
  "name": "hour",
  "type": "STRING",    # カテゴリ変数として扱うため
  "mode": "REQUIRED"
}
```

**数値 vs 文字列の選択**:
- **数値**: 機械学習で大小関係を学習してしまう
- **文字列**: カテゴリとして独立したパターンを学習

### BigQueryのMODE設定
```python
REQUIRED:  # NULL不可、必ず値が必要
NULLABLE:  # NULL可、空でもOK（デフォルト）
REPEATED:  # 配列データ
```

### パーティションとクラスタリング
```python
# パーティション（日付ベース） = 完全分離
# → 対象外の日付は100%スキップ

# クラスタリング（時刻ベース） = 効率的並び替え  
# → 関連データを近くに配置、部分的にスキップ
```

## 🔥 **NEW** データ設計思想の確立
### 「計算可能なものはテーブルに持たない」原則
```sql
-- ❌ 事前計算してテーブルに保存
usage_rate: 74.2

-- ✅ 動的計算（Looker Studio等で）
使用率 = SUM(actual_power) / SUM(supply_capacity) * 100
```

**メリット**: データ不整合防止、計算式変更への柔軟対応

### 自動化 vs 手動の判断基準
```python
# 自動化すべき: 頻繁に実行される処理
- データ転送、ETLパイプライン

# 手動で十分: 稀にしか変更されない設定  
- スキーマ作成、テーブル設計
```

**YAGNI原則**: You Aren't Gonna Need It（本当に必要になってから実装）

## 🔥 **NEW** BigQuery EXTERNAL TABLE の理解
### EXTERNAL TABLE とは
```sql
-- 通常のテーブル: データがBigQuery内に物理保存
CREATE TABLE my_table (name STRING, age INT64);
INSERT INTO my_table VALUES ('Alice', 25);

-- EXTERNAL TABLE: GCS上のファイルを仮想的に参照
CREATE EXTERNAL TABLE my_external_table (
  name STRING, age INT64
) OPTIONS (
  format = 'CSV',
  uris = ['gs://my-bucket/data.csv']
);
```

### なぜEXTERNAL TABLEを使うのか
```sql
-- ❌ 存在しない理想的な構文
INSERT INTO table FROM GCS_FILES('gs://bucket/*.csv')

-- ✅ 実際の回避策
CREATE EXTERNAL TABLE → SELECT with 型変換 → INSERT → DROP
```

**BigQueryの制約を回避する標準パターン**

### EXTERNAL TABLEの処理フロー
```sql
-- Step 1: GCS上のCSVを仮想テーブルとして定義
CREATE EXTERNAL TABLE temp_csv (...) OPTIONS (uris = ['gs://...'])

-- Step 2: 型変換しながらINSERT
INSERT INTO real_table 
SELECT PARSE_DATE('%Y-%m-%d', date), CAST(power AS FLOAT64)
FROM temp_csv

-- Step 3: 仮想テーブル削除（GCSファイルは残る）
DROP EXTERNAL TABLE temp_csv
```

## 🔥 **NEW** CMD制御構文の実践理解
### CMDの順次実行特性
```cmd
python script1.py  # この処理が100%完了するまで待つ
python script2.py  # 上が完了してから実行開始
```

**並列実行しない**: startコマンド付けない限り順次処理

### for文による一括処理
```cmd
# CMD for文で連続実行
for %m in (202301 202302 202303) do python -m src.pipelines.main_etl --month %m

# 各値が順番に%mに代入されて実行
```

### WHERE TRUE の意味
```sql
DELETE FROM table WHERE TRUE;  -- 明示的な全削除意図
DELETE FROM table