🎓 Python・プログラミング学習まとめ

🔥 クラス・オブジェクト指向の完全理解
インスタンス化の本質
pythonuploader = GCSUploader("bucket-name")  # オブジェクト作成
df = pd.DataFrame(data)                # 同じ仕組み

重要な気づき: ライブラリも自作クラスも同じインスタンス化
設計思想: 1つのオブジェクトが複数のメソッドを持つ
実用性: upload_file() と upload_directory() を1つのオブジェクトで提供

メソッドの階層設計
pythondef upload_directory(self, ...):
    for file in files:
        uri = self.upload_file(file)  # 単一処理の再利用

単一責任の原則: 各メソッドが明確な役割を持つ
コードの再利用: 複雑な処理を単純な処理の組み合わせで実現
保守性: 1箇所修正すれば全体に反映


🔥 ファイル・ディレクトリ操作の深層理解
os.walk() の動作原理
pythonfor root, dirs, files in os.walk("data/raw/202504"):
    # 1回目: root="data/raw/202504", files=["file1.csv", "file2.csv"]
    # 2回目: root="data/raw/202504/hoge", files=["file3.csv"]

階層処理: 深さごとに順番に探索
root の変化: 各ループで基準ディレクトリが移動
構造理解: 対応関係ではなく、各階層の独立処理

相対パス計算の仕組み
pythonrel_path = os.path.relpath(local_file_path, local_dir_path)
gcs_path = os.path.join(destination_prefix, rel_path)

構造保持: ローカルのディレクトリ構造をGCS上で再現
ルートの置き換え: 基準ディレクトリを新しい場所に移植
os.path の本質: 文字列操作ライブラリ（ディレクトリオブジェクトは存在しない）

パス区切り文字の理解
pythongcs_path.replace("\\", "/")  # Windows → GCS変換

クロスプラットフォーム対応: Windows \ → GCS /
OS依存性: os.path.join() がOS固有の区切り文字を使用
統一の必要性: GCSは Unix スタイル(/)を期待


🔥 Python文字列・エスケープの完全理解
文字列リテラル vs 実際の文字
python# 外部から取得（エスケープ不要）
path = os.path.join("upload", "folder")  # "upload\folder" (Windows)

# Python内で直接記述（エスケープ必要）
path.replace("\\", "/")  # \\ で \ 1文字を表現

取得と記述の違い: 変数の中身 vs コード中の表記
エスケープの必要性: Python文字列リテラルでの \ 表現は \\
実際の処理: ロジックは \ → / だが、記述は "\\" が必要

f文字列の型判定
pythonprint(f"{name}")     # 文字列として表示
print(f"{my_dict}")  # 辞書として表示  
print(f"{error}")    # エラーメッセージとして表示

自動判定: Pythonがオブジェクト型を認識して適切な表示
__str__() 呼び出し: 各型の文字列表現メソッドを自動実行
統一記法: 同じ {} でも中身の型により動作が変化


🔥 例外処理の実用的マスター
階層的例外キャッチ
pythontry:
    uploader.upload_file("non_existent_file.txt")
except FileNotFoundError as e:     # 特定のエラー
    print_result(True, f"期待通りのエラー - {e}")
except Exception as e:             # その他すべて
    print_result(False, f"予期しないエラー - {e}")

順序の重要性: 具体的なエラー → 汎用的なエラーの順
テスト思想: 期待されるエラー vs 予期しないエラーの区別
エラーオブジェクト: {e} でメッセージ部分を自動抽出

raise と try-except の分離
python# エラー発生側
if not os.path.exists(file_path):
    raise FileNotFoundError(f"File not found: {file_path}")

# エラー処理側  
try:
    some_function()
except FileNotFoundError as e:
    handle_error(e)

責任分離: エラー発生とエラー処理を分離
プログラム継続: try-except でキャッチすれば停止しない
情報伝達: エラーメッセージで詳細情報を伝達


🔥 Python構文の大幅拡張
リスト内包表記の構造
python[f for f in files if f.endswith('.csv')]
# ↓ 展開すると
result = []
for f in files:
    if f.endswith('.csv'):
        result.append(f)

3要素構成: [結果 for 変数 in リスト if 条件]
暗黙のappend: 最初の部分が append() の引数に相当
変数名自由: [hoge for f in files] でも動作

enumerate() とカウント処理
pythonfor i, uri in enumerate(uris[:3]):
    print(f"  [{i+1}] {uri}")

file_count += len(files)  # ファイル数をカウント

インデックス付きループ: 組み込み関数でimport不要
len() の意味: 文字数ではなく要素数
階層別カウント: os.walk() の各階層でファイル数を合計


🔥 組み込み関数 vs ライブラリの理解
組み込み関数（import不要）
pythonlen(), print(), enumerate(), range()
FileNotFoundError, ValueError, Exception
外部ライブラリ（import必要）
pythonimport pandas as pd
from google.cloud import storage

判断基準: import文の有無で識別
標準装備: よく使う機能はPythonに標準搭載
拡張機能: 専門的な機能は外部ライブラリ


🛠 実用的スキル・開発ツール
Python実行オプション
bashpython script.py           # ファイル直接実行
python -m module.name      # モジュール実行（推奨）

-m の利点: インポートパスが正しく設定される
実用ルール: プロジェクト内スクリプトは -m 使用
害がない: 単独スクリプトでも -m 使用可能

VS Code・開発環境

保存確認: ファイル名右の白い丸● で未保存を識別
作業ディレクトリ: os.getcwd() で現在位置確認
よくあるミス: 保存し忘れ、タイポ、インデント間違い


🏗 設計・アーキテクチャ思考
責任分離設計

GCSUploader: 汎用的なアップロード機能のみ
パイプラインスクリプト: ビジネスロジック（命名ルール等）
外部設定: パス指定、命名ルールはクラス外で決定

テスト設計思想

段階的テスト: 初期化 → 単一処理 → 一括処理 → エラー処理
期待値検証: ファイル数一致、URI形式確認、構造保持確認
手動テストの位置づけ: 本格的テストコードへの準備段階


💡 最重要な学び
「複雑な処理は単純な処理の組み合わせ」
この設計思想は実務でのシステム設計における根本的な考え方。単一責任の原則、コードの再利用性、保守性の向上など、プログラマー的思考の基盤となる概念を完全に体感できました。